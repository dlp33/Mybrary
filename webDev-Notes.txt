==== 
Promises
https://www.youtube.com/watch?v=DHvZLI7Db8E
====
Promise ==> two results === (resolve, reject)
let p = new Promise((resolve, reject) => {

});

note: 
- anything inside of a .then runs for a resolve
- .catch === our reject states.
Steps:
1. Create a promise
2. Tell it what we want it to do when it succeeds.
3. Tell it what we want it to do when it fails. 
Then ==>
1. Do this WHEN it succeeds.
2. Do this WHEN it fails. 

NOTE:
- They work great when you need to do something that is going to take a long time in the background ie. downloading an image ... and you want to do something after it's completed ==> instead of making everything else wait for it. 

====
Async Await
https://www.youtube.com/watch?v=V_Kr9OSfDeU
====
==> Syntactical sugar wrapped around making promises easier to work with.

Note:
- Asyn/Await requires some function that the awaiting code is inside of. 
- The code must be wrapped in a function with the async keyword.
- Must use the 'await' keyword for all asyncronous code. Otherwise it will just return the Promise and NOT the result of the promise. 

async function doWork() {
  // await says the code should wait until the function makeRequest is finished, then afterwards it will execute the next thing. 
  // makeRequest() will return the RESOLVE section of the Promise.
try {
  const response = await makeRequest('Google');
  console.log('Response Received');
  const processedResponse = await processRequest(response);
  console.log(processedResponse);
  } catch (err) {
    console.log(err);
  }
}
doWork()

==> Handling errors with async/await === try and .catch
- Inside of the try brackets ... add in all of the code that could potentially fail. 

====================================================
Full Stack Web Development Course
https://www.youtube.com/watch?v=qj2oDkvc4dQ&list=PLZlA0Gpn_vH8jbFkBjOuFjhxANC63OmXM&index=6&t=0s
====================================================
Video 1:
npm init -y
- y uses default values. 

npm i --save--dev nodemon
==> saves nodemon as a development dependency.
==> Use if we only want to use locally. 

dotenv library
==> Allows us to load environment variables into our application.

Partials
- All template files that aren't actually related to routes.

Forms
==> Action === the URL that the form goes to.

Anchor tags
<a></a> ==> used to link things whereas Buttons are used to interact with forms or other objects. 

NOTE:
Min 12:30 video 2...
==> FORM INPUTS ==> creates a partial file, because form inputs are shared between the new file and edit file. Don't duplicate. 

Note: Video #2 - 25:35
eg: Author.find({})
==> pass in an empty object the find function to tell the db that we have no conditions.

Video 2 - 29:31
req.query instead of req.body 
==> BECAUSE a .GET request sends through the query string: ?name=Darren

new RegExp(req.query.name, 'i')
==> The 'i' flag means case-insensitive. 

Note: Video 3 4:10 ==> When possible store files in the file system, on the server, rather than in the DB.

// Created inside the Book model. 
==> References the Author object's ID.
  author: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'Author'
  }

Vid #3 ==> 8:55 ... discussion on what code to include in views and what to include in server.js. 
==> *** Don't search the DB from inside the Views... instead do that in the Routes and pass the variable to the Views. 

Vid #3 ==> 20:15 ==> Multer
- Allows us to work with multi-part forms === fileForm. 
<h2>New Book</h2>
<form action="/books" method="POST" enctype = "multipart/form-data">

coverImageBasePath
- created inside the Book model
- The path to where all the cover images are stored. 

const uploadPath = path.join('public', Book.coverImageBasePath);
==> Combines together two different paths. 
==> Combines publick folder and Book.coverImageBasePath (which is defined in the book model as: const coverImageBasePath = 'uploads/bookCovers';)
- Joining === public/uploads/bookCovers


#3 40:20
let query = Book.find();
==> returns a query object which we can build a query from and then execute later
  query.exec()
43:30
lte = less than or equal to.
query = query.lte('publishDate', req.query.publishedBefore);
==> if the 'publishDate' (db value) is <= publishedBefore date ==> then return that object. 


====
npm run devstart
====

